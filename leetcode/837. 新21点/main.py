#!/usr/bin/env python
# coding=utf-8

"""
爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下：

爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。
 每次抽取都是独立的，其结果具有相同的概率。
当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？

示例 1：

输入：N = 10, K = 1, W = 10
输出：1.00000
说明：爱丽丝得到一张卡，然后停止。
示例 2：

输入：N = 6, K = 1, W = 10
输出：0.60000
说明：爱丽丝得到一张卡，然后停止。
在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。
示例 3：

输入：N = 21, K = 17, W = 10
输出：0.73278
提示：

0 <= K <= N <= 10000
1 <= W <= 10000
如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。
此问题的判断限制时间已经减少。

链接：https://leetcode-cn.com/problems/new-21-game
"""


class Solution(object):
    def new21GameWrong(self, N, K, W):
        """
        :type N: int
        :type K: int
        :type W: int
        :rtype: float
        """
        f = {0: 0}
        s = {0: 0}
        i = 1
        while i <= W:
            f[i] = 1 + s[i - 1]
            s[i] = f[i] + s[i - 1]
            i += 1

        while i < K:
            f[i] = s[i - 1] - s[i - 1 - W]
            s[i] = s[i - 1] + f[i]
            i += 1

        p = q = 0
        j = W + 1
        i = K
        while i <= K + W - 1:
            if i <= W:
                x = s[K - 1] + 1
            else:
                x = s[K - 1] - s[i - W - 1]
            p += x
            if i <= N:
                q += x

            i += 1
            j -= 1

        return 1.0 * q / p

    def new21Game(self, N, K, W):
        """
        每次动态规划应该多几个维度去思考，正向，反向
        设f[i] 代表手中有i积分的时候获胜的几率
        1.我们可以确定的是最终的结果范围一定是[k, k+w-1],
        因为题目规定是>=k的时候就停止
        所以当分数i在 [k, k+w-1]之间的时候，我们获胜的概率不是0就是1
        因为这个时候我们是不用在投点数了，只需要比较i和n的大小就可以确定
        那么当 i = k- 1的时候，投点数相加的结果在 [k, k+w-1]之间，这之间
        的每个结果都有可能随机得到，每个结果的概率是 1/w
        因此可以推出来， f[i] = (f[i+1]+...+f[i+w]) / w (0 <= i < = k-1)
        进一步推算，f[i-1] = (f[i]+...+f[i+w-1]) / w
        f[i-1] - f[i] = (f[i] - f[i+w]) / w
        f[i-1] = f[i]+(f[i])-f[i+w)/w
        => f[i] = f[i+1] + (f[i+1] - f[i+w+1]) / w (0<=i<=k-2)
        这样可以在o(1)时间内推到出 f[i]
        而当 i = k-1的时候
        f[k-1] = (f[k] + ... + f[k+w-1])/w
        而 f[k] ~ f[k+w-1]中的概率非0即1，我们只要看 k~k+w-1中 <= N的个数有几个即可
        快速确定
        """
        f = {}
        i = K
        while i <= W + K:
            f[i] = 1 if i <= N else 0
            i += 1

        f[K - 1] = 1.0 * min(N - K + 1, W) / W

        i = K - 2
        while i >= 0:
            f[i] = f[i + 1] + (f[i + 1] - f[i + 1 + W]) / W
            i -= 1

        return f[0]


if __name__ == '__main__':
    print Solution().new21Game(21, 17, 10)
